## SQL

### Индексы

#### Виды индексов:

- `Кластеризованный` индекс хранит реальные данные в узлах (листьях). Все значения отсортированы; таблица может иметь только один кластеризованный индекс. Кластеризованный индекс – это и есть таблица.

- `Не кластеризованный` cодержит указатели на строки с реальными данными в таблице.

#### Виды индексов по способу хранения:

- `hashmap` - хеширование, для хранения чисел.

- `bitmap` - почти не используется.

- `binary tree` - бинарное дерево для хранения строковых данных.

- `b-tree` - би-дерево, используется когда много повторяющихся строковых значений.

#### Типы индексов:

- `Составной индекс` может содержать от 1 до 16 столбцов.

- `Уникальный индекс` создается автоматически, когда вы определяете ключ как первичный или уникальный.

- `Покрывающий индекс` позволяет конкретному запросу сразу получить все необходимые данные с узлов (листьев) индекса без дополнительных обращений к записям самой таблицы.

#### Производительность индексов:

- Для таблиц которые **часто обновляются** используйте как можно **меньше** индексов.

- Использовать индексы только **на больших таблицах**. Возможно использование поиска по индексу может занять больше времени, чем простое сканирование всех строк.

- **Уникальность значений** в столбце. Чем больше у вас дубликатов в столбце, тем хуже работает индекс.

- Запрос должен включать поиск по полям, в первую очередь, с самым высоким количеством уникальных значений.

```SQL
SELECT * FROM `table` WHERE `name`='Яблоко' AND `price`=500
```

- Первичный ключ не должен иметь тип `NULL`.

### Полиморфные связи

Виды:
- Один-к-одному
- Один-ко-многим
- Многие-ко-многим

Связь `многие-ко-многим` состоит из двух связей `один-ко-многим`. Создается с помощью **трех таблиц**. При создании применяется специальный `FOREIGN KEY` индекс.

```SQL
CREATE TABLE books_authors (
  id int NOT NULL,
  books_id int NOT NULL,
  authors_id int(10),
  keywords int(10),
  PRIMARY KEY (id),
  FOREIGN KEY (books_id) REFERENCES books(id)
);
```

### Репликация
